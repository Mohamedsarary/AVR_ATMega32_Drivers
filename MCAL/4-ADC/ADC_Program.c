/*
 *  	Created on: 18/09/2023
 *      LAYER : MCAL
 *      Author: Mohamed sarary
 *      File  : ADC_Program.c
 */

#include "../../SERVICES/StdTypes.h"
#include "../../SERVICES/BitMath.h"
#include "../../SERVICES/ErrorStates.h"

#include "ADC_Config.h"
#include "ADC_Interface.h"
#include "ADC_Private.h""


u8 ADC_u8Init(void)
{
	u8 Func_State = Func_NOK ;
#if ADC_VREF_MODE == AREF
	CLR_BIT(ADMUX,ADMUX_REFS0);
	CLR_BIT(ADMUX,ADMUX_REFS1);

#elif ADC_VREF_MODE == AVCC
	SET_BIT(ADMUX,ADMUX_REFS0);
	CLR_BIT(ADMUX,ADMUX_REFS1);

#elif ADC_VREF_MODE == INT_2_56
	SET_BIT(ADMUX,ADMUX_REFS0);
	SET_BIT(ADMUX,ADMUX_REFS1);

#else
	#error ("WRONG REFERENCE VOLTAGE OF ADC!")

#endif


#if ADC_ADJ_MODE == ADC_LEFT_ADJ
	SET_BIT(ADMUX,ADMUX_ADLAR);

#elif ADC_ADJ_MODE == ADC_RIGHT_ADJ
	CLR_BIT(ADMUX,ADMUX_ADLAR);

#else
	#error ("WRONG ADJUST RESULT OF ADC!")
#endif


#if ADC_PRESACLLER_MODE == ADC_DIV_2
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
	CLR_BIT(ADCSRA,ADCSRA_ADPS1);
	CLR_BIT(ADCSRA,ADCSRA_ADPS2);
	Func_State = Func_OK;

#elif ADC_PRESACLLER_MODE == ADC_DIV_4
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
	CLR_BIT(ADCSRA,ADCSRA_ADPS2);
	Func_State = Func_OK;

#elif ADC_PRESACLLER_MODE == ADC_DIV_8
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
	CLR_BIT(ADCSRA,ADCSRA_ADPS2);
	Func_State = Func_OK;

#elif ADC_PRESACLLER_MODE == ADC_DIV_16
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
	CLR_BIT(ADCSRA,ADCSRA_ADPS1);
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
	Func_State = Func_OK;

#elif ADC_PRESACLLER_MODE == ADC_DIV_32
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
	CLR_BIT(ADCSRA,ADCSRA_ADPS1);
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
	Func_State = Func_OK;

#elif ADC_PRESACLLER_MODE == ADC_DIV_64
	CLR_BIT(ADCSRA,ADCSRA_ADPS0);
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
	Func_State = Func_OK;

#elif ADC_PRESACLLER_MODE == ADC_DIV_128
	SET_BIT(ADCSRA,ADCSRA_ADPS0);
	SET_BIT(ADCSRA,ADCSRA_ADPS1);
	SET_BIT(ADCSRA,ADCSRA_ADPS2);
	Func_State = Func_OK;

#else
	#error ("WRONG PRESACLLER OF ADC!")
#endif

#if ADC_RUNNING_MODE == ADC_SINGLE_CONV
	CLR_BIT(ADCSRA,ADCSRA_ADATE);
	Func_State = Func_OK;

#elif ADC_RUNNING_MODE == ADC_AUTO_TRIG
	SET_BIT(ADCSRA,ADCSRA_ADATE);
	Func_State = Func_OK;

	#if ADC_AUTO_TRIGGER_MODE == ADC_FREE_RUNNING
	CLR_BIT(SFIOR,SFIOR_ADTS0);
	CLR_BIT(SFIOR,SFIOR_ADTS1);
	CLR_BIT(SFIOR,SFIOR_ADTS2);
	Func_State = Func_OK;

	#elif ADC_AUTO_TRIGGER_MODE == ADC_ANALOG_COMP
	SET_BIT(SFIOR,SFIOR_ADTS0);
	CLR_BIT(SFIOR,SFIOR_ADTS1);
	CLR_BIT(SFIOR,SFIOR_ADTS2);
	Func_State = Func_OK;

	#elif ADC_AUTO_TRIGGER_MODE == ADC_EXTI_REQ0
	CLR_BIT(SFIOR,SFIOR_ADTS0);
	SET_BIT(SFIOR,SFIOR_ADTS1);
	CLR_BIT(SFIOR,SFIOR_ADTS2);
	Func_State = Func_OK;

	#elif ADC_AUTO_TRIGGER_MODE == ADC_TIMER0_CMP
	SET_BIT(SFIOR,SFIOR_ADTS0);
	SET_BIT(SFIOR,SFIOR_ADTS1);
	CLR_BIT(SFIOR,SFIOR_ADTS2);
	Func_State = Func_OK;

	#elif ADC_AUTO_TRIGGER_MODE == ADC_TIMER0_OVF
	CLR_BIT(SFIOR,SFIOR_ADTS0);
	CLR_BIT(SFIOR,SFIOR_ADTS1);
	SET_BIT(SFIOR,SFIOR_ADTS2);
	Func_State = Func_OK;

	#elif ADC_AUTO_TRIGGER_MODE == ADC_TIMER1_CMP
	SET_BIT(SFIOR,SFIOR_ADTS0);
	CLR_BIT(SFIOR,SFIOR_ADTS1);
	SET_BIT(SFIOR,SFIOR_ADTS2);
	Func_State = Func_OK;

	#elif ADC_AUTO_TRIGGER_MODE == ADC_TIMER1_OVF
	CLR_BIT(SFIOR,SFIOR_ADTS0);
	SET_BIT(SFIOR,SFIOR_ADTS1);
	SET_BIT(SFIOR,SFIOR_ADTS2);
	Func_State = Func_OK;

	#elif ADC_AUTO_TRIGGER_MODE == ADC_TIMER1_CP_EV
	SET_BIT(SFIOR,SFIOR_ADTS0);
	SET_BIT(SFIOR,SFIOR_ADTS1);
	SET_BIT(SFIOR,SFIOR_ADTS2);
	Func_State = Func_OK;

	#else
		#error ("WRONG AUTO TRIGGER MODE OF ADC!")
	Func_State = Func_NOK ;
	#endif
	#endif

	CLR_BIT(ADCSRA,ADCSRA_ADIE);
	SET_BIT(ADCSRA,ADCSRA_ADEN);
	return Func_State ;
}

u8 ADC_u8ENB(void)
{
	u8 Func_State = Func_NOK ;
	SET_BIT(ADCSRA,ADCSRA_ADEN);
	Func_State = Func_OK ;
	return Func_State;
}

u8 ADC_u8DIS(void)
{
	u8 Func_State = Func_NOK ;
	CLR_BIT(ADCSRA,ADCSRA_ADEN);
	Func_State = Func_OK ;
	return Func_State;
}

u8 ADC_INTENB(void)
{
	u8 Func_State = Func_NOK ;
	SET_BIT(ADCSRA,ADCSRA_ADIE);
	Func_State = Func_OK ;
	return Func_State;
}

u8 ADC_INTDIS(void)
{
	u8 Func_State = Func_NOK ;
	CLR_BIT(ADCSRA,ADCSRA_ADIE);
	Func_State = Func_OK ;
	return Func_State;
}

u16 ADC_u8GetChannelVal(u8 Copy_u8CHANNEL)
{
	u16 Local_u16Value = 0 ;

	Copy_u8CHANNEL &= 0x07 ;

	ADMUX &= 0xE0 ;   			  /* CLEAR MUX BITS IN ADMUX REGISTER */

	ADMUX |= Copy_u8CHANNEL ;	 /* SET CHANNEL IN MUX BITS */

	SET_BIT(ADCSRA,ADCSRA_ADSC);

	while(0 == GET_BIT(ADCSRA, ADCSRA_ADIF));

if (GET_BIT(ADCSRA,ADCSRA_ADIF) == 1)
	{
#if ADC_ADJ_MODE == ADC_RIGHT_ADJ
	Local_u16Value = ADCL | ( ADCH << 8 );
#elif ADC_ADJ_MODE == ADC_LEFT_ADJ
	Local_u16Value = ADCH << 2 ;
#endif
	}
	SET_BIT(ADCSRA , ADCSRA_ADIF);
	return Local_u16Value ;
}

void ADC_FCallBack(void (*ADC_PCALLBACK)(void))
{
	if ( ADC_PCALLBACK != NULL )
	{
		ADC_CallBack = ADC_PCALLBACK ;
	}
}

void __vector_16 (void)
{
	ADC_CallBack();
}
